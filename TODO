Моя вторая операционная система
Ideal
C interface !! !! ! !

Info
----
Требует gcc

TODO. Сейчас
------------
Switch to Multiboot 2! !
Перечитать man gcc! !
-fno-exceptions -fno-stack-protector ?

Markers
-------
TODO
LATER
I386 (этим маркером помечены наиболее незаметные i386-specific места)

Если я захочу сделать реальную, полнофункциональную ОС
------------------------------------------------------
Установить в ядре (и, возможно, в user space) правильные EFLAGS

Советы начинающим создателям ОС [ideal, в том числе название, markdown]
-------------------------------
* Если линковать при помощи gcc и не давать ему никаких опций об input/output format (не путать с emulator), то gcc предполагает, что это ELF, даже если в linker script написано иначе (gcc не читает linker script). В результате gcc устанавливает макрос __ELF__, что может привести к ошибкам. Поэтому правильный способ сборки - это всегда использовать gcc, и не вызывать низкоуровневые утилиты вроде ld напрямую. Также не нужно использовать linker script
* Если не контролировать место размещения ядра в памяти, то по умолчанию оно получается слишком большим и не влезает в 128 мебибайт (1 мебибайт = 1024 кибибайт, 1 мегабайт = 1000 килобайт по стандарту IEEE), которые используются по умолчанию в Qemu. Поэтому при линковке нужно указать опцию -Wl,-Ttext-segment=АДРЕС к gcc (не -Wl,-Ttext=АДРЕС)
* Если собирать ассемблерный код при помощи g++, то всё OK, но если собирать C-исходники при помощи g++, то g++ понимает, что это действительно C, а не C++, но использует C++-овые соглашения о вызовах
