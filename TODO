Моя вторая операционная система
Ideal
C interface !! !! ! !

Info
----
Требует gcc

Маркер TODO
-----------
может, переписать на C? (см. аргументы в статье на англ. "Почему бы не переписать Linux kernel на C++?"), в том числе то, что прога на C будет меньше бинарно (провести эксперимент? мож, ещё и баги fake user space пропадут?? xD)
	написать компилятор некоторого подмножества C++, чтобы был такой же хороший код, как и в C?

добавление block_mult вызвало unbootable

panic_internal и panic_external!!

не получается запустить исошник в VirtualBox

модуль по-английски будет unit, а не module? поэтому переименовать kprintfm в kprintfu?

Прочие маркеры
--------------
LATER
I386 (этим маркером помечены наиболее незаметные i386-specific места)
TIME (исправить для ускорения)

Если я захочу сделать реальную, полнофункциональную ОС (маркер REAL)
--------------------------------------------------------------------
Удалить шуточный README, screenshot.png и duo.iso

Установить в ядре (и, возможно, в user space) правильные EFLAGS

Заюзать restrict везде, где надо

Советы начинающим создателям ОС [ideal, в том числе название, markdown]
-------------------------------
* Если линковать при помощи gcc и не давать ему никаких опций об input/output format (не путать с emulator), то gcc предполагает, что это ELF, даже если в linker script написано иначе (gcc не читает linker script). В результате gcc устанавливает макрос __ELF__, что может привести к ошибкам. Поэтому правильный способ сборки - это всегда использовать gcc, и не вызывать низкоуровневые утилиты вроде ld напрямую. Также не нужно использовать linker script
* Если не контролировать место размещения ядра в памяти, то по умолчанию оно получается слишком большим и не влезает в 128 мебибайт (1 мебибайт = 1024 кибибайт, 1 мегабайт = 1000 килобайт по стандарту IEEE), которые используются по умолчанию в Qemu. Поэтому при линковке нужно указать опцию -Wl,-Ttext-segment=АДРЕС к gcc (не -Wl,-Ttext=АДРЕС)
* Если собирать ассемблерный код при помощи g++, то всё OK, но если собирать C-исходники при помощи g++, то g++ понимает, что это действительно C, а не C++, но использует C++-овые соглашения о вызовах
* Билт-ины gcc типа __builtin_strlen иногда работают "просто так", а иногда не работают и требуют настоящих функций типа strlen. Таким образом, настоящие функции всегда надо реализовывать вручную
